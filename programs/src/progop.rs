//! This module contains the enum of valid operators in an RPN program

use std::fmt;

use colored::*;

/// RPN program items and operators
#[derive(Clone, Copy, Hash, Eq, PartialEq)]
pub enum ProgOp {
    /// A number
    Number(u8),
    /// Addition operator
    OpAdd,
    /// Subtraction operator
    OpSub,
    /// Multiplication operator
    OpMul,
    /// Division operator
    OpDiv,
}

impl ProgOp {
    /// Returns the string representation of a program operator, optionally coloured
    pub fn colour(&self, numbers: &[u32], colour: bool) -> String {
        let mut res = match self {
            ProgOp::Number(n) => numbers[*n as usize].to_string(),
            ProgOp::OpAdd => "+".to_string(),
            ProgOp::OpSub => "-".to_string(),
            ProgOp::OpMul => "×".to_string(),
            ProgOp::OpDiv => "/".to_string(),
        };

        if colour {
            res = match self {
                ProgOp::Number(_) => res.on_blue().to_string(),
                ProgOp::OpAdd | ProgOp::OpSub | ProgOp::OpMul | ProgOp::OpDiv => res.dimmed().to_string(),
            }
        }

        res
    }
}

impl fmt::Debug for ProgOp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Number(n) => write!(f, "{}", n),
            Self::OpAdd => write!(f, "+"),
            Self::OpSub => write!(f, "-"),
            Self::OpMul => write!(f, "×"),
            Self::OpDiv => write!(f, "/"),
        }
    }
}

/// Processes a set of instructions calling callbacks for numbers and operations
#[inline]
pub fn process_instructions<S, N, T>(
    instructions: &[ProgOp],
    stack: &mut Vec<S>,
    mut num_cb: N,
    mut op_cb: T,
) -> Option<S>
where
    N: FnMut(u8) -> Option<S>,
    T: FnMut(S, ProgOp, S) -> Option<S>,
{
    stack.clear();

    for op in instructions {
        match op {
            ProgOp::Number(n) => stack.push(num_cb(*n)?),
            _ => {
                let n1 = stack.pop().unwrap();
                let n2 = stack.pop().unwrap();
                stack.push(op_cb(n2, *op, n1)?)
            }
        }
    }

    stack.pop()
}

/// Errors generated by RPN program run
#[derive(Debug, Eq, PartialEq)]
pub enum ProgErr {
    /// Program generated a zero intermediate result
    Zero,
    /// Program generated a negative intermediate result
    Negative,
    /// Program encountered a division by zero
    DivZero,
    /// Program encountered a non-integer intermediate result
    NonInteger,
    /// Program encountered multiply by 1 (noop)
    Mul1,
    /// Program encountered divide by 1 (noop)
    Div1,
}

/// Runs the program with a given set of numbers and preallocated stack
#[inline]
pub fn run_instructions(instructions: &[ProgOp], numbers: &[u32], stack: &mut Vec<u32>) -> Result<u32, ProgErr> {
    // NB this does not use the process function for speed
    stack.clear();

    for op in instructions {
        match op {
            ProgOp::Number(x) => stack.push(numbers[*x as usize]),
            ProgOp::OpAdd => {
                let n1 = stack.pop().unwrap();
                let n2 = stack.pop().unwrap();

                stack.push(n2 + n1);
            }
            ProgOp::OpSub => {
                let n1 = stack.pop().unwrap();
                let n2 = stack.pop().unwrap();

                if n2 < n1 {
                    Err(ProgErr::Negative)?
                }

                let int = n2 - n1;

                if int == 0 {
                    Err(ProgErr::Zero)?
                }

                stack.push(int);
            }
            ProgOp::OpMul => {
                let n1 = stack.pop().unwrap();
                let n2 = stack.pop().unwrap();

                if n1 == 1 || n2 == 1 {
                    Err(ProgErr::Mul1)?
                }

                let int = n2 * n1;

                if int == 0 {
                    Err(ProgErr::Zero)?
                }

                stack.push(int);
            }
            ProgOp::OpDiv => {
                let n1 = stack.pop().unwrap();
                let n2 = stack.pop().unwrap();

                if n1 == 0 {
                    Err(ProgErr::DivZero)?
                }

                if n1 == 1 {
                    Err(ProgErr::Div1)?
                }

                if n2 % n1 != 0 {
                    Err(ProgErr::NonInteger)?
                }

                stack.push(n2 / n1);
            }
        }
    }

    Ok(stack.pop().unwrap())
}

// Tests

#[cfg(test)]
mod tests {
    use super::*;
    use std::mem;

    #[test]
    fn test_size() {
        assert_eq!(2, mem::size_of::<ProgOp>());
    }
}
