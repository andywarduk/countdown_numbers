use itertools::Itertools;
use std::cmp::{min, Ordering};
use std::fmt;
use colored::*;

// Programs struct - collection of RPN program to run for a set of numbers

pub struct Programs {
    programs: Vec<Program>,
    nums: usize
}

impl Programs {

    // Create a new Programs struct
    pub fn new(nums: usize, inc_commutative: bool) -> Self {
        let operators = vec![ProgOp::OpAdd, ProgOp::OpSub, ProgOp::OpMul, ProgOp::OpDiv];

        Self::new_with_operators(nums, inc_commutative, operators)
    }

    fn new_with_operators(nums: usize, inc_commutative: bool, operators: Vec<ProgOp>) -> Self {
        let mut programs = Programs {
            programs: Vec::new(),
            nums
        };

        for num_cnt in 1..=nums {
            // Generate operator counts
            let op_count = op_counts(num_cnt);
    
            // Generate operator combintions
            let op_comb = op_combs(num_cnt, &operators);

            // Generate programs
            generate_num_programs(&mut programs, nums, num_cnt, &op_count, &op_comb, inc_commutative);
        }
    
        programs
    }

    // Returns number of programs contained in the programs collection
    pub fn len(&self) -> usize {
        self.programs.len()
    }

    // Returns true if the programs collection is empty
    pub fn is_empty(&self) -> bool {
        self.programs.is_empty()
    }

    // Adds a program to the programs collection
    fn push(&mut self, program: Program) {
        self.programs.push(program)
    }

    // Runs all of the programs in the programs collection with a given set of numbers and returns the results
    pub fn run(&self, numbers: &Vec<u32>) -> Results {
        let mut stack: Vec<u32> = Vec::with_capacity(numbers.len());
        let mut results = Results::new();

        assert!(numbers.len() == self.nums);

        for program in &self.programs {
            match program.run(numbers, &mut stack) {
                Ok(ans) => {
                    if ans < 100 {
                        results.under_range += 1;
                    } else if ans > 999 {
                        results.above_range += 1;
                    } else {
                        results.solutions.push(Solution::new(program, ans));
                    }
                }
                Err(e) => {
                    match e {
                        ProgErr::Zero => results.zero += 1,
                        ProgErr::Negative => results.negative += 1,
                        ProgErr::DivZero => results.div_zero += 1,
                        ProgErr::NonInteger => results.non_integer += 1,
                        ProgErr::Mul1 => results.mult_by_1 += 1,
                    }
                }
            }
        }

        results
    }

    // Runs all of the programs in the programs collection with a given set of numbers and a target and returns the solutions
    pub fn run_target(&self, target: u32, numbers: &Vec<u32>) -> Vec<Solution> {
        let mut stack: Vec<u32> = Vec::with_capacity(numbers.len());
        let mut solutions = Vec::new();

        assert!(numbers.len() == self.nums);

        for program in &self.programs {
            if let Ok(ans) = program.run(numbers, &mut stack) {
                if ans == target {
                    solutions.push(Solution::new(program, ans));
                }
            }
        }

        solutions
    }

}

// ProgOp enum - RPN program items and operators

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
enum ProgOp {
    Number(u8),
    OpAdd,
    OpSub,
    OpMul,
    OpDiv
}

// ProgErr enum - errors generated by RPN program run

#[derive(Debug, Eq, PartialEq)]
enum ProgErr {
    Zero,       // Program generated a zero intermediate result
    Negative,   // Program generated a negative intermediate result
    DivZero,    // Program encountered a division by zero
    NonInteger, // Program encountered a non-integer intermediate result
    Mul1,       // Program encountered multiply by 1 (noop)
}

// ProgFmt enum - used to convert RPN program to infix style

enum ProgFmt {
    Num(u32),
    CommAdd(Vec<u32>),
    CommMul(Vec<u32>),
    Expr(String),
}

impl fmt::Display for ProgFmt {
    
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ProgFmt::Num(n) => write!(f, "{}", n.to_string().on_blue()),
            ProgFmt::CommAdd(nums) => write!(f, "({})", nums.iter().map(|n| n.to_string().on_blue()).join(&" + ".dimmed())),
            ProgFmt::CommMul(nums) => write!(f, "({})", nums.iter().map(|n| n.to_string().on_blue()).join(&" * ".dimmed())),
            ProgFmt::Expr(s) => write!(f, "({})", s),
        }
    }

}

// ProgramEntity - used to filter commutative equations

#[derive(Debug)]
enum ProgEntity {
    Card(u8),
    CommAdd(Vec<u8>),
    CommMul(Vec<u8>),
    Multi
}

// Program struct - hold a single RPN program

#[derive(Eq, PartialEq)]
struct Program {
    instructions: Vec<ProgOp>
}

impl Program {

    // Creates a new program
    fn new(num_cnt: usize) -> Self {
        Program {
            instructions: Vec::with_capacity(num_cnt + (num_cnt - 1))
        }
    }

    // Adds an instruction to the program
    fn push(&mut self, op: ProgOp) {
        self.instructions.push(op);
    } 

    // Runs the program with a given set of numbers and preallocated stack
    fn run(&self, numbers: &[u32], stack: &mut Vec<u32>) -> Result<u32, ProgErr> {
        stack.clear();

        for op in &self.instructions {
            match op {
                ProgOp::Number(x) => stack.push(numbers[*x as usize]),
                ProgOp::OpAdd => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();

                    stack.push(n2 + n1);
                },
                ProgOp::OpSub => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();

                    if n2 < n1 {
                        return Err(ProgErr::Negative)
                    }

                    let int = n2 - n1;

                    if int == 0 {
                        return Err(ProgErr::Zero)
                    }

                    stack.push(int);
                },
                ProgOp::OpMul => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();

                    if n1 == 1 || n2 == 1 {
                        return Err(ProgErr::Mul1)
                    }

                    let int = n2 * n1;

                    if int == 0 {
                        return Err(ProgErr::Zero)
                    }

                    stack.push(int);
                },
                ProgOp::OpDiv => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();

                    if n1 == 0 {
                        return Err(ProgErr::DivZero)
                    }

                    if n2 % n1 != 0 {
                        return Err(ProgErr::NonInteger)
                    }

                    stack.push(n2 / n1);
                },
            }
        }

        Ok(stack.pop().unwrap())
    }

    // Returns false if the program contains a calculation which is commutative and would be covered by another program
    fn commutative_filter(&self, stack: &mut Vec<ProgEntity>) -> bool {
        stack.clear();

        for op in &self.instructions {
            match op {
                ProgOp::Number(x) => stack.push(ProgEntity::Card(*x)),
                ProgOp::OpAdd => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();
                    
                    match n1 {
                        ProgEntity::Card(c1) => {
                            match n2 {
                                ProgEntity::Card(c2) => {
                                    // c2 + c1
                                    // Only include if first number is lower than the second
                                    if c2 < c1 { return false }
                                    let cards = vec![c2, c1];
                                    stack.push(ProgEntity::CommAdd(cards));
                                }
                                ProgEntity::CommAdd(_) => {
                                    // (c2 + c2 ...) + c1
                                    // Skip commutative expressions on the left
                                    return false;
                                }
                                ProgEntity::CommMul(_) | ProgEntity::Multi => {
                                    // (eqn) + c1
                                    // Multiple operators
                                    stack.push(ProgEntity::Multi);
                                }
                            }
                        }
                        ProgEntity::CommAdd(cards1) => {
                            match n2 {
                                ProgEntity::Card(c2) => {
                                    // c2 + (c1 + c1 ...)
                                    // Include expansions on the right hand side if first number is lower
                                    if c2 < cards1[0] { return false }
                                    let cards = [c2].iter().copied().chain(cards1.iter().copied()).collect();
                                    stack.push(ProgEntity::CommAdd(cards));
                                }
                                ProgEntity::CommAdd(_) => {
                                    // (c2 + c2 ...) + (c1 + c1 ...)
                                    // Skip commutative expressions on both sides
                                    return false;
                                }
                                ProgEntity::CommMul(_) | ProgEntity::Multi => {
                                    // (eqn) + c1
                                    // Multiple operators
                                    stack.push(ProgEntity::Multi);
                                }
                            }
                        }
                        ProgEntity::CommMul(_) | ProgEntity::Multi => {
                            // Multiple operators
                            stack.push(ProgEntity::Multi);
                        }
                    }
                },
                ProgOp::OpMul => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();
                    
                    match n1 {
                        ProgEntity::Card(c1) => {
                            match n2 {
                                ProgEntity::Card(c2) => {
                                    // c2 * c1
                                    // Only include if first number is lower than the second
                                    if c2 < c1 { return false }
                                    let cards = vec![c2, c1];
                                    stack.push(ProgEntity::CommMul(cards));
                                }
                                ProgEntity::CommMul(_) => {
                                    // (c2 * c2 ...) * c1
                                    // Skip commutative expressions on the left
                                    return false;
                                }
                                ProgEntity::CommAdd(_) | ProgEntity::Multi => {
                                    // (eqn) + c1
                                    // Multiple operators
                                    stack.push(ProgEntity::Multi);
                                }
                            }
                        }
                        ProgEntity::CommMul(cards1) => {
                            match n2 {
                                ProgEntity::Card(c2) => {
                                    // c2 * (c1 * c1 ...)
                                    // Include expansions on the right hand side if first number is lower
                                    if c2 < cards1[0] { return false }
                                    let cards = [c2].iter().copied().chain(cards1.iter().copied()).collect();
                                    stack.push(ProgEntity::CommMul(cards));
                                }
                                ProgEntity::CommMul(_) => {
                                    // (c2 * c2 ...) * (c1 * c1 ...)
                                    // Skip commutative expressions on both sides
                                    return false;
                                }
                                ProgEntity::CommAdd(_) | ProgEntity::Multi => {
                                    // (eqn) + c1
                                    // Multiple operators
                                    stack.push(ProgEntity::Multi);
                                }
                            }
                        }
                        ProgEntity::CommAdd(_) | ProgEntity::Multi => {
                            // Multiple operators
                            stack.push(ProgEntity::Multi);
                        }
                    }
                },
                ProgOp::OpSub | ProgOp::OpDiv => {
                    stack.pop().unwrap();
                    stack.pop().unwrap();
                    stack.push(ProgEntity::Multi);
                },
            }
        }

        true
    }

    // Returns the formatted steps of a program for a given set of numbers
    fn steps(&self, numbers: &[u32], colour: bool) -> Vec<String> {
        let mut result = Vec::new();
        let mut stack: Vec<u32> = Vec::with_capacity(numbers.len());
        let mut str_stack: Vec<String> = Vec::with_capacity(numbers.len());

        let oper = |str: &str| -> String {
            if colour { str.dimmed().to_string() }
            else { str.to_string() }
        };

        let card = |c: u32| -> String {
            if colour { c.to_string().on_blue().to_string() }
            else { c.to_string() }
        };

        for op in &self.instructions {
            match op {
                ProgOp::Number(x) => {
                    stack.push(numbers[*x as usize]);
                    str_stack.push(card(numbers[*x as usize]));
                },
                ProgOp::OpAdd => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();
                    let n1_str = str_stack.pop().unwrap();
                    let n2_str = str_stack.pop().unwrap();
                    let ans = n2 + n1;
                    let ans_str = ans.to_string();
                    result.push(format!("{} {} {} {} {}", n2_str, oper("+"), n1_str, oper("="), ans_str));
                    stack.push(ans);
                    str_stack.push(ans_str);
                },
                ProgOp::OpSub => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();
                    let n1_str = str_stack.pop().unwrap();
                    let n2_str = str_stack.pop().unwrap();
                    let ans = n2 - n1;
                    let ans_str = ans.to_string();
                    result.push(format!("{} {} {} {} {}", n2_str, oper("-"), n1_str, oper("="), ans_str));
                    stack.push(ans);
                    str_stack.push(ans_str);
                },
                ProgOp::OpMul => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();
                    let n1_str = str_stack.pop().unwrap();
                    let n2_str = str_stack.pop().unwrap();
                    let ans = n2 * n1;
                    let ans_str = ans.to_string();
                    result.push(format!("{} {} {} {} {}", n2_str, oper("×"), n1_str, oper("="), ans_str));
                    stack.push(ans);
                    str_stack.push(ans_str);
                },
                ProgOp::OpDiv => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();
                    let n1_str = str_stack.pop().unwrap();
                    let n2_str = str_stack.pop().unwrap();
                    let ans = n2 / n1;
                    let ans_str = ans.to_string();
                    result.push(format!("{} {} {} {} {}", n2_str, oper("/"), n1_str, oper("="), ans_str));
                    stack.push(ans);
                    str_stack.push(ans_str);
                },
            }
        }

        result
    }

    // Converts the RPN program to infix equation
    fn equation(&self, numbers: &[u32], colour: bool) -> String {
        let mut stack: Vec<ProgFmt> = Vec::new();

        let oper = |o| -> String {
            let char = match o {
                ProgOp::OpAdd => "+",
                ProgOp::OpSub => "-",
                ProgOp::OpMul => "×",
                ProgOp::OpDiv => "/",
                _ => panic!("Invalid operator")
            };

            if colour { char.dimmed().to_string() }
            else { char.to_string() }
        };

        let card = |c: u32| -> String {
            if colour { c.to_string().on_blue().to_string() }
            else { c.to_string() }
        };

        for op in self.instructions.iter() {
            match op {
                ProgOp::Number(x) => stack.push(ProgFmt::Num(numbers[*x as usize])),
                ProgOp::OpAdd => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();

                    match n1 {
                        ProgFmt::CommAdd(ref nums1) => {
                            match n2 {
                                ProgFmt::CommAdd(nums2) => {
                                    let nums = nums2.iter().copied().chain(nums1.iter().copied()).collect();
                                    stack.push(ProgFmt::CommAdd(nums));
                                }
                                ProgFmt::Num(num2) => {
                                    let nums = [num2].iter().copied().chain(nums1.iter().copied()).collect();
                                    stack.push(ProgFmt::CommAdd(nums));
                                }
                                _ => {
                                    stack.push(ProgFmt::Expr(format!("{} {} {}", n2, oper(ProgOp::OpAdd), n1)));
                                }
                            }
                        }
                        ProgFmt::Num(num1) => {
                            match n2 {
                                ProgFmt::CommAdd(nums2) => {
                                    let nums = nums2.iter().copied().chain([num1].iter().copied()).collect();
                                    stack.push(ProgFmt::CommAdd(nums));
                                }
                                ProgFmt::Num(num2) => {
                                    let nums = vec![num2, num1];
                                    stack.push(ProgFmt::CommAdd(nums));
                                }
                                _ => {
                                    stack.push(ProgFmt::Expr(format!("{} {} {}", n2, oper(ProgOp::OpAdd), n1)));
                                }
                            }
                        }
                        _ => {
                            stack.push(ProgFmt::Expr(format!("{} {} {}", n2, oper(ProgOp::OpAdd), n1)));
                        }
                    }
                },
                ProgOp::OpSub => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();

                    stack.push(ProgFmt::Expr(format!("{} {} {}", n2, oper(ProgOp::OpSub), n1)));
                },
                ProgOp::OpMul => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();

                    match n1 {
                        ProgFmt::CommMul(ref nums1) => {
                            match n2 {
                                ProgFmt::CommMul(nums2) => {
                                    let nums = nums2.iter().copied().chain(nums1.iter().copied()).collect();
                                    stack.push(ProgFmt::CommMul(nums));
                                }
                                ProgFmt::Num(num2) => {
                                    let nums = [num2].iter().copied().chain(nums1.iter().copied()).collect();
                                    stack.push(ProgFmt::CommMul(nums));
                                }
                                _ => {
                                    stack.push(ProgFmt::Expr(format!("{} {} {}", n2, oper(ProgOp::OpMul), n1)));
                                }
                            }
                        }
                        ProgFmt::Num(num1) => {
                            match n2 {
                                ProgFmt::CommMul(nums2) => {
                                    let nums = nums2.iter().copied().chain([num1].iter().copied()).collect();
                                    stack.push(ProgFmt::CommMul(nums));
                                }
                                ProgFmt::Num(num2) => {
                                    let nums = vec![num2, num1];
                                    stack.push(ProgFmt::CommMul(nums));
                                }
                                _ => {
                                    stack.push(ProgFmt::Expr(format!("{} {} {}", n2, oper(ProgOp::OpMul), n1)));
                                }
                            }
                        }
                        _ => {
                            stack.push(ProgFmt::Expr(format!("{} {} {}", n2, oper(ProgOp::OpMul), n1)));
                        }
                    }
                },
                ProgOp::OpDiv => {
                    let n1 = stack.pop().unwrap();
                    let n2 = stack.pop().unwrap();

                    stack.push(ProgFmt::Expr(format!("{} {} {}", n2, oper(ProgOp::OpDiv), n1)));
                },
            }
        }

        let result = match stack.pop().unwrap() {
            ProgFmt::Expr(s) => s,
            ProgFmt::CommAdd(nums) => nums.iter().map(|n| card(*n)).join(&" + ".dimmed()),
            ProgFmt::CommMul(nums) => nums.iter().map(|n| card(*n)).join(&" × ".dimmed()),
            ProgFmt::Num(n) => card(n),
        };

        result
    }

    // Converts the RPN program to a string for a given set of numbers
    fn rpn(&self, numbers: &[u32], colour: bool) -> String {
        let oper = |str: &str| -> String {
            if colour { str.dimmed().to_string() }
            else { str.to_string() }
        };

        let card = |c: u32| -> String {
            if colour { c.to_string().on_blue().to_string() }
            else { c.to_string() }
        };

        self.instructions.iter().map(|&i| {
            match i {
                ProgOp::Number(n) => card(numbers[n as usize]),
                ProgOp::OpAdd => oper("+"),
                ProgOp::OpSub => oper("-"),
                ProgOp::OpMul => oper("×"),
                ProgOp::OpDiv => oper("/"),
            }
        }).join(" ")
    }

}

impl fmt::Debug for Program {

    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let prog_str = self.instructions.iter().map(|&i| {
            match i {
                ProgOp::Number(n) => format!("n[{}]", n.to_string()),
                ProgOp::OpAdd => "+".to_string(),
                ProgOp::OpSub => "-".to_string(),
                ProgOp::OpMul => "*".to_string(),
                ProgOp::OpDiv => "/".to_string(),
            }
        }).join(" ");

        write!(f, "{}", prog_str)
    }

}

// Results struct - Holds the results of running all programs with a set of numbers

#[derive(Default)]
pub struct Results<'a> {
    pub solutions: Vec<Solution<'a>>, // Valid solution collection
    pub under_range: usize,           // Number of programs with answer below valid range
    pub above_range: usize,           // Number of programs with answer above valid range
    pub zero: usize,                  // Number of programs with zero intermediate result
    pub negative: usize,              // Number of programs with negative intermediate result
    pub div_zero: usize,              // Number of programs encountering division by zero
    pub non_integer: usize,           // Number of programs with non-integer intermediate result
    pub mult_by_1: usize              // Number of programs containing a multipy by 1
}

impl<'a> Results<'a> {

    // Create new Result
    fn new() -> Self {
        Results::default()
    }

}

// Solutions struct - holds the result of running a program

#[derive(Eq)]
pub struct Solution<'a> {
    program: &'a Program,
    pub result: u32
}

impl<'a> Solution<'a> {

    fn new(program: &'a Program, result: u32) -> Self {
        Solution {
            program,
            result
        }
    }

    pub fn program_equation(&self, numbers: &[u32]) -> String {
        format!("{} {} {}", self.program.equation(numbers, true), "=".dimmed(), self.result)
    }

    pub fn program_steps(&self, numbers: &[u32]) -> Vec<String> {
        self.program.steps(numbers, true)
    }

    pub fn program_rpn(&self, numbers: &[u32]) -> String {
        self.program.rpn(numbers, true)
    }

}

impl<'a> Ord for Solution<'a> {

    fn cmp(&self, other: &Self) -> Ordering {
        let mut ord = self.result.cmp(&other.result);

        if ord == Ordering::Equal {
            ord = self.program.instructions.len().cmp(&other.program.instructions.len())
        }

        ord
    }

}

impl<'a> PartialOrd for Solution<'a> {

    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }

}

impl<'a> PartialEq for Solution<'a> {

    fn eq(&self, other: &Self) -> bool {
        self.result == other.result && self.program.instructions.len() == other.program.instructions.len()
    }

}

// Support functions

fn generate_num_programs(programs: &mut Programs, nums: usize, num_cnt: usize, op_counts: &OpCounts, op_combs: &Vec<Vec<ProgOp>>, inc_commutative: bool) {
    let mut comm_stack = Vec::with_capacity(nums);

    for nums in (0..nums).permutations(num_cnt) {
        if num_cnt == 1 {
            let mut program = Program::new(num_cnt);

            // Push the number
            program.push(ProgOp::Number(nums[0] as u8));

            programs.push(program);

        } else {
            for op_count in op_counts {
                for op_comb in op_combs {
                    let mut program = Program::new(num_cnt);
                    let mut op_index = 0;

                    // Push first number
                    program.push(ProgOp::Number(nums[0] as u8));

                    for i in 0..(num_cnt - 1) {
                        // Push number
                        program.push(ProgOp::Number(nums[i + 1] as u8));

                        // Push operators
                        for _ in 0..op_count[i] {
                            program.push(op_comb[op_index]);
                            op_index += 1;
                        }
                    }

                    // Commutative check
                    if inc_commutative || program.commutative_filter(&mut comm_stack) {
                        programs.push(program);
                    }
                }
            }
            
        }
    }
}

type OpCounts = Vec<Vec<usize>>;

fn op_counts(nums: usize) -> OpCounts {
    let mut results = Vec::new();

    if nums > 1 {
        op_counts_rec(&mut results, Vec::with_capacity(nums - 1), 0, nums - 1, nums - 1, 2);
    }

    results
}

fn op_counts_rec(results: &mut OpCounts, mut current: Vec<usize>, slot: usize, slots: usize, to_alloc: usize, stacked: usize) {
    if slot == slots - 1 {
        // Allocate all to the last slot
        current.push(to_alloc);
        results.push(current);

    } else {
        // How many can we allocate to this slot?
        let max_stack = stacked - 1;

        for i in 0..=min(to_alloc - 1, max_stack) {
            let mut next = current.clone();
            next.push(i);
            let next_stacked = stacked + 1 - i;
            op_counts_rec(results, next, slot + 1, slots, to_alloc - i, next_stacked);
        }

    }
}

type OpCombs = Vec<Vec<ProgOp>>;

fn op_combs(nums: usize, operators: &Vec<ProgOp>) -> OpCombs {
    let mut results = Vec::new();

    if nums > 1 {
        op_combs_rec(&mut results, Vec::with_capacity(nums - 1), 0, nums - 1, operators);
    }

    results
}

fn op_combs_rec(results: &mut OpCombs, current: Vec<ProgOp>, slot: usize, slots: usize, operators: &Vec<ProgOp>) {
    let mut add = |op: ProgOp| {
        let mut next = current.clone();
        next.push(op);

        if slot == slots - 1 {
            results.push(next)
        } else {
            op_combs_rec(results, next, slot + 1, slots, operators)
        }
    };

    for op in operators.iter() {
        add(*op);
    }
}

// Tests

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn prog_add() {
        let mut stack: Vec<u32> = Vec::new();
        let mut program = Program::new(2);

        program.push(ProgOp::Number(0));
        program.push(ProgOp::Number(1));
        program.push(ProgOp::OpAdd);

        assert_eq!(Ok(7), program.run(&[3, 4], &mut stack));
    }

    #[test]
    fn prog_sub() {
        let mut stack: Vec<u32> = Vec::new();
        let mut program = Program::new(2);

        program.push(ProgOp::Number(0));
        program.push(ProgOp::Number(1));
        program.push(ProgOp::OpSub);

        assert_eq!(Ok(4), program.run(&[7, 3], &mut stack));
        assert_eq!(Err(ProgErr::Zero), program.run(&[3, 3], &mut stack));
        assert_eq!(Err(ProgErr::Negative), program.run(&[3, 4], &mut stack));
    }

    #[test]
    fn prog_mul() {
        let mut stack: Vec<u32> = Vec::new();
        let mut program = Program::new(2);

        program.push(ProgOp::Number(0));
        program.push(ProgOp::Number(1));
        program.push(ProgOp::OpMul);

        assert_eq!(Ok(21), program.run(&[7, 3], &mut stack));
        assert_eq!(Err(ProgErr::Mul1), program.run(&[7, 1], &mut stack));
        assert_eq!(Err(ProgErr::Mul1), program.run(&[1, 3], &mut stack));
        assert_eq!(Err(ProgErr::Zero), program.run(&[7, 0], &mut stack));
        assert_eq!(Err(ProgErr::Zero), program.run(&[0, 3], &mut stack));
        assert_eq!(Err(ProgErr::Zero), program.run(&[0, 0], &mut stack));
    }

    #[test]
    fn prog_div() {
        let mut stack: Vec<u32> = Vec::new();
        let mut program = Program::new(2);

        program.push(ProgOp::Number(0));
        program.push(ProgOp::Number(1));
        program.push(ProgOp::OpDiv);

        assert_eq!(Ok(4), program.run(&[12, 3], &mut stack));
        assert_eq!(Err(ProgErr::NonInteger), program.run(&[13, 3], &mut stack));
        assert_eq!(Err(ProgErr::DivZero), program.run(&[3, 0], &mut stack));
    }

    #[test]
    fn commutative_filter_test_mul() {
        let programs = Programs::new_with_operators(4, false, vec![ProgOp::OpMul]);

        let numbers = vec![1, 2, 3, 4];

        for p in &programs.programs {
            println!("RPN: {}  Equation: {}", p.rpn(&numbers, true), p.equation(&numbers, true));
        }

        assert_eq!(15, programs.len());

        assert_eq!("1", programs.programs[0].equation(&numbers, false));
        assert_eq!("2", programs.programs[1].equation(&numbers, false));
        assert_eq!("3", programs.programs[2].equation(&numbers, false));
        assert_eq!("4", programs.programs[3].equation(&numbers, false));

        assert_eq!("2 × 1", programs.programs[4].equation(&numbers, false));
        assert_eq!("3 × 1", programs.programs[5].equation(&numbers, false));
        assert_eq!("3 × 2", programs.programs[6].equation(&numbers, false));
        assert_eq!("4 × 1", programs.programs[7].equation(&numbers, false));
        assert_eq!("4 × 2", programs.programs[8].equation(&numbers, false));
        assert_eq!("4 × 3", programs.programs[9].equation(&numbers, false));

        assert_eq!("3 × 2 × 1", programs.programs[10].equation(&numbers, false));
        assert_eq!("4 × 2 × 1", programs.programs[11].equation(&numbers, false));
        assert_eq!("4 × 3 × 1", programs.programs[12].equation(&numbers, false));
        assert_eq!("4 × 3 × 2", programs.programs[13].equation(&numbers, false));

        assert_eq!("4 × 3 × 2 × 1", programs.programs[14].equation(&numbers, false));
    }

    #[test]
    fn commutative_filter_test_add() {
        let programs = Programs::new_with_operators(4, false, vec![ProgOp::OpAdd]);

        let numbers = vec![1, 2, 3, 4];

        for p in &programs.programs {
            println!("RPN: {}  Equation: {}", p.rpn(&numbers, true), p.equation(&numbers, true));
        }

        assert_eq!(15, programs.len());

        assert_eq!("1", programs.programs[0].equation(&numbers, false));
        assert_eq!("2", programs.programs[1].equation(&numbers, false));
        assert_eq!("3", programs.programs[2].equation(&numbers, false));
        assert_eq!("4", programs.programs[3].equation(&numbers, false));

        assert_eq!("2 + 1", programs.programs[4].equation(&numbers, false));
        assert_eq!("3 + 1", programs.programs[5].equation(&numbers, false));
        assert_eq!("3 + 2", programs.programs[6].equation(&numbers, false));
        assert_eq!("4 + 1", programs.programs[7].equation(&numbers, false));
        assert_eq!("4 + 2", programs.programs[8].equation(&numbers, false));
        assert_eq!("4 + 3", programs.programs[9].equation(&numbers, false));

        assert_eq!("3 + 2 + 1", programs.programs[10].equation(&numbers, false));
        assert_eq!("4 + 2 + 1", programs.programs[11].equation(&numbers, false));
        assert_eq!("4 + 3 + 1", programs.programs[12].equation(&numbers, false));
        assert_eq!("4 + 3 + 2", programs.programs[13].equation(&numbers, false));

        assert_eq!("4 + 3 + 2 + 1", programs.programs[14].equation(&numbers, false));
    }

}
